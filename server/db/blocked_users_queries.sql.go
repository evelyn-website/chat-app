// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: blocked_users_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const blockUser = `-- name: BlockUser :one
INSERT INTO blocked_users (blocker_id, blocked_id)
VALUES ($1, $2)
ON CONFLICT (blocker_id, blocked_id) DO NOTHING
RETURNING id, blocker_id, blocked_id, created_at
`

type BlockUserParams struct {
	BlockerID uuid.UUID `json:"blocker_id"`
	BlockedID uuid.UUID `json:"blocked_id"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) (BlockedUser, error) {
	row := q.db.QueryRow(ctx, blockUser, arg.BlockerID, arg.BlockedID)
	var i BlockedUser
	err := row.Scan(
		&i.ID,
		&i.BlockerID,
		&i.BlockedID,
		&i.CreatedAt,
	)
	return i, err
}

const checkBlockConflictWithGroup = `-- name: CheckBlockConflictWithGroup :one
SELECT EXISTS(
    SELECT 1 FROM user_groups ug
    JOIN blocked_users bu ON
        (bu.blocker_id = ug.user_id AND bu.blocked_id = $1)
        OR (bu.blocker_id = $1 AND bu.blocked_id = ug.user_id)
    WHERE ug.group_id = $2 AND ug.deleted_at IS NULL
) AS has_conflict
`

type CheckBlockConflictWithGroupParams struct {
	BlockedID uuid.UUID  `json:"blocked_id"`
	GroupID   *uuid.UUID `json:"group_id"`
}

func (q *Queries) CheckBlockConflictWithGroup(ctx context.Context, arg CheckBlockConflictWithGroupParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkBlockConflictWithGroup, arg.BlockedID, arg.GroupID)
	var has_conflict bool
	err := row.Scan(&has_conflict)
	return has_conflict, err
}

const checkBlockExists = `-- name: CheckBlockExists :one
SELECT EXISTS(
    SELECT 1 FROM blocked_users
    WHERE (blocker_id = $1 AND blocked_id = $2) OR (blocker_id = $2 AND blocked_id = $1)
) AS is_blocked
`

type CheckBlockExistsParams struct {
	BlockerID uuid.UUID `json:"blocker_id"`
	BlockedID uuid.UUID `json:"blocked_id"`
}

func (q *Queries) CheckBlockExists(ctx context.Context, arg CheckBlockExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkBlockExists, arg.BlockerID, arg.BlockedID)
	var is_blocked bool
	err := row.Scan(&is_blocked)
	return is_blocked, err
}

const getBlockedUsers = `-- name: GetBlockedUsers :many
SELECT u.id, u.username, u.email, u.created_at, u.updated_at, bu.created_at AS blocked_at
FROM blocked_users bu
JOIN users u ON u.id = bu.blocked_id
WHERE bu.blocker_id = $1
ORDER BY bu.created_at DESC
`

type GetBlockedUsersRow struct {
	ID        uuid.UUID        `json:"id"`
	Username  string           `json:"username"`
	Email     string           `json:"email"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	BlockedAt pgtype.Timestamp `json:"blocked_at"`
}

func (q *Queries) GetBlockedUsers(ctx context.Context, blockerID uuid.UUID) ([]GetBlockedUsersRow, error) {
	rows, err := q.db.Query(ctx, getBlockedUsers, blockerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedUsersRow
	for rows.Next() {
		var i GetBlockedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BlockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedGroupIDs = `-- name: GetSharedGroupIDs :many
SELECT ug1.group_id FROM user_groups ug1
JOIN user_groups ug2 ON ug1.group_id = ug2.group_id
WHERE ug1.user_id = $1 AND ug2.user_id = $2
  AND ug1.deleted_at IS NULL AND ug2.deleted_at IS NULL
`

type GetSharedGroupIDsParams struct {
	UserID   *uuid.UUID `json:"user_id"`
	UserID_2 *uuid.UUID `json:"user_id_2"`
}

func (q *Queries) GetSharedGroupIDs(ctx context.Context, arg GetSharedGroupIDsParams) ([]*uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getSharedGroupIDs, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*uuid.UUID
	for rows.Next() {
		var group_id *uuid.UUID
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unblockUser = `-- name: UnblockUser :exec
DELETE FROM blocked_users WHERE blocker_id = $1 AND blocked_id = $2
`

type UnblockUserParams struct {
	BlockerID uuid.UUID `json:"blocker_id"`
	BlockedID uuid.UUID `json:"blocked_id"`
}

func (q *Queries) UnblockUser(ctx context.Context, arg UnblockUserParams) error {
	_, err := q.db.Exec(ctx, unblockUser, arg.BlockerID, arg.BlockedID)
	return err
}
