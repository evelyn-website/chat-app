// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cleanup_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearGroupImageUrl = `-- name: ClearGroupImageUrl :exec
UPDATE groups SET image_url = NULL, blurhash = NULL WHERE id = $1
`

// Nulls out the image_url after S3 cleanup so the group isn't reprocessed
func (q *Queries) ClearGroupImageUrl(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearGroupImageUrl, id)
	return err
}

const deleteMessagesForGroup = `-- name: DeleteMessagesForGroup :exec
DELETE FROM messages
WHERE group_id = $1
`

// Deletes all messages for a specific group
func (q *Queries) DeleteMessagesForGroup(ctx context.Context, groupID *uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessagesForGroup, groupID)
	return err
}

const deleteUserGroupsForGroup = `-- name: DeleteUserGroupsForGroup :exec
UPDATE user_groups SET deleted_at = NOW()
WHERE group_id = $1 AND deleted_at IS NULL
`

// Soft-deletes all user_groups relationships for a specific group
func (q *Queries) DeleteUserGroupsForGroup(ctx context.Context, groupID *uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserGroupsForGroup, groupID)
	return err
}

const getExpiredGroups = `-- name: GetExpiredGroups :many

SELECT id, name, end_time
FROM groups
WHERE end_time < NOW() AND deleted_at IS NULL
ORDER BY end_time ASC
LIMIT $1
`

type GetExpiredGroupsRow struct {
	ID      uuid.UUID        `json:"id"`
	Name    string           `json:"name"`
	EndTime pgtype.Timestamp `json:"end_time"`
}

// Cleanup Expired Groups Queries
// Returns groups that have passed their end_time
func (q *Queries) GetExpiredGroups(ctx context.Context, limit int32) ([]GetExpiredGroupsRow, error) {
	rows, err := q.db.Query(ctx, getExpiredGroups, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredGroupsRow
	for rows.Next() {
		var i GetExpiredGroupsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoftDeletedGroupsNeedingCleanup = `-- name: GetSoftDeletedGroupsNeedingCleanup :many
SELECT g.id, g.name, g.deleted_at
FROM groups g
WHERE g.deleted_at IS NOT NULL
  AND (
    EXISTS (SELECT 1 FROM messages m WHERE m.group_id = g.id)
    OR g.image_url IS NOT NULL
  )
ORDER BY g.deleted_at ASC
LIMIT $1
`

type GetSoftDeletedGroupsNeedingCleanupRow struct {
	ID        uuid.UUID        `json:"id"`
	Name      string           `json:"name"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

// Returns soft-deleted groups that still have messages or S3 data to clean up
func (q *Queries) GetSoftDeletedGroupsNeedingCleanup(ctx context.Context, limit int32) ([]GetSoftDeletedGroupsNeedingCleanupRow, error) {
	rows, err := q.db.Query(ctx, getSoftDeletedGroupsNeedingCleanup, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoftDeletedGroupsNeedingCleanupRow
	for rows.Next() {
		var i GetSoftDeletedGroupsNeedingCleanupRow
		if err := rows.Scan(&i.ID, &i.Name, &i.DeletedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleDeviceKeys = `-- name: GetStaleDeviceKeys :many

SELECT user_id, device_identifier, last_seen_at
FROM device_keys
WHERE last_seen_at < NOW() - INTERVAL '90 days'
ORDER BY last_seen_at ASC
`

type GetStaleDeviceKeysRow struct {
	UserID           uuid.UUID        `json:"user_id"`
	DeviceIdentifier string           `json:"device_identifier"`
	LastSeenAt       pgtype.Timestamp `json:"last_seen_at"`
}

// Cleanup Stale Device Keys Queries
// Returns device keys that haven't been seen in 90+ days
func (q *Queries) GetStaleDeviceKeys(ctx context.Context) ([]GetStaleDeviceKeysRow, error) {
	rows, err := q.db.Query(ctx, getStaleDeviceKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStaleDeviceKeysRow
	for rows.Next() {
		var i GetStaleDeviceKeysRow
		if err := rows.Scan(&i.UserID, &i.DeviceIdentifier, &i.LastSeenAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleGroupReservations = `-- name: GetStaleGroupReservations :many

SELECT group_id, user_id, created_at
FROM group_reservations
WHERE created_at < NOW() - INTERVAL '24 hours'
ORDER BY created_at ASC
`

// Cleanup Stale Reservations Queries
// Returns group reservations older than specified interval
func (q *Queries) GetStaleGroupReservations(ctx context.Context) ([]GroupReservation, error) {
	rows, err := q.db.Query(ctx, getStaleGroupReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupReservation
	for rows.Next() {
		var i GroupReservation
		if err := rows.Scan(&i.GroupID, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userHasActiveGroups = `-- name: UserHasActiveGroups :one
SELECT EXISTS (
    SELECT 1
    FROM user_groups ug
    JOIN groups g ON ug.group_id = g.id
    WHERE ug.user_id = $1
      AND g.end_time > NOW()
      AND ug.deleted_at IS NULL
      AND g.deleted_at IS NULL
) AS has_active_groups
`

// Checks if user is in any groups that haven't expired yet
func (q *Queries) UserHasActiveGroups(ctx context.Context, userID *uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, userHasActiveGroups, userID)
	var has_active_groups bool
	err := row.Scan(&has_active_groups)
	return has_active_groups, err
}
